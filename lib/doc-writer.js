/**
 * A doctor writer module
 * @module doctor/writer
 */

const esprima = require('esprima');
const util = require('util');
const fs = require('fs');
const docUtils = require('./doc-utils');

const Doctor = require('./structures/Doctor');

/**
 * @param {string} path - Either a filepath or a glob
 * @param {Object} [options]
 * @returns {{status: string, error: ?boolean}}
 */
function doctor(path, options = {}) {
    return docUtils.validateFiles(path).then(validFiles => {
        const doctoredFiles = validFiles.map(file => doctorFile(file, options));

        return Promise.all(doctoredFiles).then(() => {
            return {status: "success"};
        }, error => {
            return {status: "failure", error};
        });
    });
}

/**
 * @param {string} filePath - A file path
 * @param {Object} [options]
 * @returns {undefined}
 * @throws {Error} An error ocurred while tperforming IO, parsing, or doctoring operations
 */
function doctorFile(filePath, options = {}) {
    const readFile = util.promisify(fs.readFile);

    return readFile(filePath, 'utf8').then(content => {
        content = content.toString();

        let contentExplanation = parseCode(content);
        let doctor = new Doctor(content, contentExplanation, options);

        let output = doctor.toString();
        return fs.writeFileSync(filePath, output);
    }).catch(error => {
        throw error;
    });
}

/**
 * @param {string} content - source code as a string
 * @returns {Object} - An explanation object generated by parsing the source code
 */
function parseCode(content) {
    return esprima.parseScript(content, {
        comment: true,
        loc: true,
        tokens: true
    });
}

module.exports = {
    parseCode,
    doctor,
    doctorFile
};